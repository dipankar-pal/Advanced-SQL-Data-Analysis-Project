/*data checking--- EDA */
-- Explore all objects in the Database
SELECT * 
FROM 
    INFORMATION_SCHEMA.TABLES

--EXPLORE ALL COLUMNS IN THE DATABASE

SELECT *
FROM 
    INFORMATION_SCHEMA.COLUMNS


--EXPLORE DIMENSIONS VALUE
SELECT
     DISTINCT [country]
FROM 
    [gold].[dim_customers]

--EXPLORE ALL PRODUCT CATEGORIES  'THE MAJOR DIVISION'
SELECT
     DISTINCT [category],[subcategory],[product_name]
FROM
    [gold].[dim_products]

--DATE EXPLORATION
--IDENTIFY  THE EARLIEST AND LATEST DATES (BOUNDARIES)
--HOW MANY YEARS OF SALES ARE AVAIABLE
SELECT 
     MIN([order_date]) AS MIN_ORDER_DATE,
	 MAX([order_date]) AS MAX_ORDER_DATE,
	 DATEDIFF(MONTH, MIN([order_date]),MAX([order_date])) AS MONTH_SALES_RANGE,
	 DATEDIFF(YEAR, MIN([order_date]),MAX([order_date])) AS YEAR_SALES_RANGE
FROM [gold].[fact_sales]

--FIND THE YOUNGEST AND THE OLDEST CUSTOMER
SELECT
     MIN([birthdate]) AS ODEST_BIRTHDATE,
	 DATEDIFF(YEAR,MIN([birthdate]),GETDATE()) AS OLDEST_AGE,
	 MAX([birthdate]) AS YOUBGEST_BIRTHDATE,
	 DATEDIFF(YEAR,MAX([birthdate]),GETDATE()) AS YOUNGEST_AGE
FROM [gold].[dim_customers]

/*MEASURES  EXPLORATION*/

--FIND THE TOTAL SALES
SELECT 
   SUM([sales_amount]) AS TOTAL_SALES
FROM [gold].[fact_sales]

--FIND HOW MANY ITEMS ARE SOLD
SELECT 
     COUNT([product_key])AS TOTAL_PRODUCT_SOLD
FROM [gold].[fact_sales]

--FIND THE AVERAGE SELLING PRICE
SELECT
     AVG([price]) AS AVG_SELLING_PRICE
FROM [gold].[fact_sales]

--FIND TOTAL NUMBER OF ORDERS
SELECT
    COUNT([order_number]) AS TOTAL_ORDER
FROM [gold].[fact_sales]
--------
SELECT
    COUNT(DISTINCT[order_number]) AS DISTINCT_TOTAL_ORDER        
FROM [gold].[fact_sales]

--FIND TOTAL NUMBER OF PRODUCTS
SELECT
    COUNT([product_key]) AS TOTAL_PRODUCT
FROM
    [gold].[dim_products]

--FIND TOTAL NUMBER OF CUSTOMERS
SELECT
     COUNT([customer_key]) AS TOTAL_CUSTOMER
FROM [gold].[dim_customers]

--FIND THE TOTAL NUMBER OF CUSTOMERS THAT HAS PLACED AN ORDER
SELECT
     COUNT(DISTINCT[customer_key]) AS TOTAL_CUSTOMER
FROM [gold].[fact_sales]

--Generate a report that shows all key metrics of the busness
SELECT 
   'total_sales' AS MEASURE_NAME,
   SUM([sales_amount]) AS TOTAL_SALES
FROM [gold].[fact_sales]
UNION ALL
SELECT 
     'item_sold' AS MEASURE_NAME,
     COUNT([product_key])AS TOTAL_PRODUCT_SOLD
FROM [gold].[fact_sales]
UNION ALL
SELECT
     'avg_selling_price' AS MEASURE_NAME,
     AVG([price]) AS AVG_SELLING_PRICE
FROM [gold].[fact_sales]
UNION ALL
SELECT
    'total_order' AS MEASURE_NAME,
    COUNT([order_number]) AS TOTAL_ORDER
FROM [gold].[fact_sales]
UNION ALL
SELECT
    'total_product' AS MEASURE_NAME,
    COUNT([product_key]) AS TOTAL_PRODUCT
FROM
    [gold].[dim_products]
UNION ALL
SELECT
     'total_customer' AS MEASURE_NAME,
     COUNT([customer_key]) AS TOTAL_CUSTOMER
FROM [gold].[dim_customers]

--Find total customer by countries
SELECT
     [country],
	 COUNT([customer_key]) AS TOTAL_CUSTOMER
FROM [gold].[dim_customers]
GROUP BY 
       [country]
ORDER BY 
       2 DESC

--Find total customer by gender
SELECT
     [gender],
	 COUNT([customer_key]) AS TOTAL_CUSTOMER
FROM [gold].[dim_customers]
GROUP BY 
       [gender]
ORDER BY 
       2 DESC

--Find total product by category
SELECT
     [category],
	 COUNT([product_key]) AS total_product
FROM
    [gold].[dim_products]
GROUP BY
     [category]
ORDER BY
     2 DESC
--what is the average costs in each category?
SELECT
      [category],
	  AVG([cost]) AS AVG_COST
FROM [gold].[dim_products]
GROUP BY [category]
ORDER BY 2 DESC
--what is the total revenue generated by each category?
SELECT
     [category],
	 SUM([sales_amount]) AS TOTAL_REVU_GENA
FROM [gold].[fact_sales]
LEFT JOIN [gold].[dim_products]
ON [gold].[dim_products].product_key = [gold].[fact_sales].product_key
GROUP BY [category]
ORDER BY 2 DESC
--find total revenue is generated by each customer
SELECT 
     CONCAT([first_name],' ',[last_name]) AS CUSTOMER_NAME,
	 SUM([sales_amount]) AS TOTAL_REVU_GENA
FROM [gold].[fact_sales]
LEFT JOIN [gold].[dim_customers]
ON [gold].[dim_customers].customer_key = [gold].[fact_sales].customer_key
GROUP BY CONCAT([first_name],' ',[last_name])
--what is the distribution of sold items across countries?
SELECT 
     [country],
	 SUM([quantity]) AS ITEM_SOLD
FROM [gold].[fact_sales]
LEFT JOIN [gold].[dim_customers]
ON [gold].[dim_customers].customer_key = [gold].[fact_sales].customer_key
GROUP BY   [country]
ORDER BY 2 DESC
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------  
/*CHANGE OVER TIME ANALYSIS
---YEAR----*/
SELECT YEAR(order_date) AS SALES_YEAR,
       SUM(sales_amount) AS TOTAL_SALES,
	   SUM(quantity) AS TOTAL_QUANTITY,
	   COUNT([customer_key]) AS TOTAL_CUSTOMER,
	   COUNT([order_number]) AS TOTAL_ORDER
	   FROM [gold].[fact_sales]
WHERE
     order_date IS NOT NULL
GROUP BY 
       YEAR(order_date)
ORDER BY
        YEAR(order_date)


/*CALCULATE THE TOTAL SALES PER MONTH
AND THE RUNNING TOTAL OF SALLES OVER TIME*/
SELECT 
      ORDER_DATE,
	  TOTAL_SALES,
	  SUM( TOTAL_SALES) OVER (PARTITION BY  ORDER_DATE ORDER BY ORDER_DATE) AS RUNNING_TITAL_SALES,
      AVG(AVG_PRICE) OVER (PARTITION BY  ORDER_DATE ORDER BY ORDER_DATE) AS MOVING_AVG_PRICE
FROM(
     SELECT 
          DATETRUNC(MONTH,[order_date]) AS ORDER_DATE,
          SUM([sales_amount]) AS TOTAL_SALES ,
	      AVG([price]) AS AVG_PRICE
     FROM 
	      [gold].[fact_sales]
     WHERE 
	      order_date IS NOT NULL
     GROUP BY
          DATETRUNC(MONTH,[order_date])
		   ) AS TABL
      

/*Analyze the yearly performance of products by comparing their sales to both the 
average sales performance of the product and the previous years sales*/

SELECT 
     SALES_YEAR,
	 product_name,
	 SALES,
	 AVG(SALES) OVER (PARTITION BY product_name) AS AVG_SALES,
	 SALES-AVG(SALES) OVER (PARTITION BY product_name) AS DIFF_AVG,
CASE 
     WHEN SALES-AVG(SALES) OVER (PARTITION BY product_name) > 0 THEN 'ABOVE AVG'
	 WHEN SALES-AVG(SALES) OVER (PARTITION BY product_name) < 0 THEN 'BELOW AVG'
	 ELSE 'AVG'
END AS AVG_CHANGE,
LAG(SALES) OVER (PARTITION BY  product_name ORDER BY SALES_YEAR) AS PY_SALES,
SALES - LAG(SALES) OVER (PARTITION BY  product_name ORDER BY SALES_YEAR) AS DIFF_PY,
CASE
    WHEN SALES - LAG(SALES) OVER (PARTITION BY  product_name ORDER BY SALES_YEAR) > 0 THEN 'INCREASE'
	WHEN SALES - LAG(SALES) OVER (PARTITION BY  product_name ORDER BY SALES_YEAR) < 0 THEN 'DECREASE'
	ELSE 'NO CHANGE'
END AS PY_CHANGE
FROM(
     SELECT 
    YEAR([order_date]) AS SALES_YEAR,
	[product_name],
	SUM([sales_amount]) AS SALES
FROM [gold].[dim_products]
LEFT JOIN [gold].[fact_sales]
ON
    [gold].[fact_sales].product_key = [gold].[dim_products].product_key
WHERE order_date IS NOT NULL
GROUP BY
    YEAR([order_date]),
	[product_name]
) AS V


---WHICH CATEGORIES CONTRIBUTE THE MOST TO OVERALL SALES?
SELECT
     category,
	 TOTAL_SALES,
	 SUM(TOTAL_SALES) OVER () AS OVARALL_SALES,
CONCAT(
    ROUND(
        (CAST(TOTAL_SALES AS FLOAT) / SUM(TOTAL_SALES) OVER ()) * 100, 
        2
    ), 
    '%'
) AS PER_CONTRIBUTE

FROM(
SELECT 
      category,
	  SUM(sales_amount) AS TOTAL_SALES
	  
FROM [gold].[dim_products]
JOIN [gold].[fact_sales]
ON
  [gold].[dim_products].product_key = [gold].[fact_sales].product_key
group by 
          category
) AS G
ORDER BY PER_CONTRIBUTE DESC


/*Segment product into cost range and
count how many products fall into each segment*/

SELECT 
     PRODUCT_SEGMENT,
	 COUNT(product_name) AS TOTAL_PRODUCT
FROM(
     select 
         product_name,
	     cost,
CASE WHEN cost < 100 THEN 'BELOW 100'
     WHEN cost BETWEEN 100 AND 500 THEN '100-500'
	 WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
	 ELSE 'ABOVE 1000'
END AS PRODUCT_SEGMENT
from [gold].[dim_products]
) AS S
GROUP BY PRODUCT_SEGMENT
ORDER BY TOTAL_PRODUCT DESC


/*Group customer into three segment based on their spending behavior:
   -VIP: Customer with at lest 12 months of history and spending more then 5000.
   -Regular: Customer with at least 12 months of history but spending 5000 or less.
   -New : Customer with a lifespan less then 12 months.
and find the total number of customer by each group*/

SELECT 
     S_B_GROUP,
	 COUNT(customer_key) AS TOTAL_CUSTOMER
                               FROM(
                                    SELECT 
                                        C.[customer_key], 
                                        SUM(sales_amount) AS TOTAL_SPENDING,
	                                    MIN(order_date) AS FIRST_ORDER,
	                                    MAX(order_date) AS LAST_ORDER,
	                                    DATEDIFF (MONTH,MIN(order_date),MAX(order_date)) AS LIFESPAN,
                                    CASE 
                                            WHEN  DATEDIFF (MONTH,MIN(order_date),MAX(order_date)) >= 12 AND
	                                                    SUM(sales_amount)> 5000 
		                                                           THEN 'VIP'
                                            WHEN  DATEDIFF (MONTH,MIN(order_date),MAX(order_date)) >= 12 AND
	                                                     SUM(sales_amount)<= 5000 
		                                                             THEN 'Regular'
                                            WHEN DATEDIFF (MONTH,MIN(order_date),MAX(order_date)) <= 12 
	                                                                 THEN 'NEW'
											ELSE 'UNKNOWN'
                                   END AS S_B_GROUP
                                   FROM [gold].[dim_customers] AS C
                                   JOIN [gold].[fact_sales]
                                   ON 
                                     [gold].[fact_sales].customer_key = C.customer_key
								   WHERE 
      								 order_date IS NOT NULL
                                   GROUP BY 
                                     C.[customer_key]
								
) AS L
GROUP BY S_B_GROUP
ORDER BY TOTAL_CUSTOMER DESC


/*
Customer Report :

Purpose:
        -This report consolidates key customer metrics and behaviors

Highlights:
      1. Gathers essential fields such as names ,age and transaction details.
	  2. Segments customer into categories (VIP,Regular,New) and age groups.
	  3. Aggregates customer-level metrics:
	               - total order
				   - total sales
				   - total quantity purchased
				   - total products
				   -lifespan (in months)
	   4. Calculate valuable KPIs:
	               - recency (months since last order)
				   - average order value
				   - average monthly spend
------------------------------------------------------------------------------------------------
*/
--1) Base query: Retrieves  core columns from tables
SELECT
    customer_key,
	customer_number,
	customer_name,
	AGE,
	COUNT(DISTINCT order_number) AS total_orders,
	SUM(sales_amount) AS total_sales,
	SUM(quantity) AS total_quantity,
	COUNT(DISTINCT product_key) AS total_product,
	MAX(order_date) AS last_order_date,
	DATEDIFF(MONTH,MIN(order_date),MAX(order_date)) as lifespen
FROM
(
SELECT 
      f.[order_date],
	  f.product_key,
	  f.order_number,
	  f.quantity,
	  f.sales_amount,
	  c.customer_key,
	  c.customer_number,
	  CONCAT(C.first_name, ' ' ,c.last_name) AS customer_name,
	  DATEDIFF(YEAR,c.birthdate,GETDATE()) AS AGE
	  
FROM [gold].[fact_sales] f
left join [gold].[dim_customers] c
ON
  c.customer_key = f.customer_key
WHERE 
     [order_date] IS NOT NULL
) AS Base_query
	  
group by
        customer_key,
	customer_number,
	customer_name,
	AGE


---2. Segments customer into categories (VIP,Regular,New) and age groups.


---final query
CREATE VIEW gold.customer_report AS
SELECT
    customer_key,
	customer_number,
	customer_name,
	AGE,
	CASE
	    WHEN AGE < 20 THEN 'UNDER 20'
		WHEN AGE BETWEEN 20 AND 29 THEN '20-29'
		WHEN AGE BETWEEN 30 AND 39 THEN '30-39'
		WHEN AGE BETWEEN 40 AND 49 THEN '40-49'
		ELSE '50 AND ABOVE'
	END AS AGE_GROUP,
	CASE
	    WHEN lifespen >= 12 AND total_sales> 5000 THEN 'VIP'
		WHEN lifespen >= 12 AND total_sales<= 5000 THEN 'Regular'
		ELSE 'NEW'
	END AS customer_segment,
	last_order_date,
-- recency (months since last order)
    DATEDIFF(MONTH, last_order_date,GETDATE()) AS RECENCY,
	total_orders,
	total_sales,
	total_quantity,
	total_product,
	lifespen,
-- average order value
    CASE 
	    WHEN total_sales = 0 THEN 0
		ELSE total_sales / total_orders
	END AS avg_order_value,
-- average monthly spend
    CASE
	    WHEN lifespen = 0 THEN total_sales
		ELSE total_sales / lifespen
	END AS avg_monthly_spend
FROM(
----1) Base query: Retrieves  core columns from tables
SELECT
    customer_key,
	customer_number,
	customer_name,
	AGE,
	COUNT(DISTINCT order_number) AS total_orders,
	SUM(sales_amount) AS total_sales,
	SUM(quantity) AS total_quantity,
	COUNT(DISTINCT product_key) AS total_product,
	MAX(order_date) AS last_order_date,
	DATEDIFF(MONTH,MIN(order_date),MAX(order_date)) as lifespen
FROM
(
SELECT 
      f.[order_date],
	  f.product_key,
	  f.order_number,
	  f.quantity,
	  f.sales_amount,
	  c.customer_key,
	  c.customer_number,
	  CONCAT(C.first_name, ' ' ,c.last_name) AS customer_name,
	  DATEDIFF(YEAR,c.birthdate,GETDATE()) AS AGE
	  
FROM [gold].[fact_sales] f
left join [gold].[dim_customers] c
ON
  c.customer_key = f.customer_key
WHERE 
     [order_date] IS NOT NULL
) AS Base_query
	  
group by
        customer_key,
	customer_number,
	customer_name,
	AGE
) AS customer_aggregation;



/*================================================================================================================================================ */



/* 
Product Report:
purpose:
       - This report consolidates key product metrics and behaviors .
Highlight:
       1. Gathers essentials fields such as product name, category, subcategory, and cost.
	   2. Segments products by revenue to identify high-Performers, Mid-Range, or Low-Performers.
	   3. Aggregates product-level metrics:
	            - total orders
				- total sales
				- total quentity sold
				- total customers (unique)
				- lifespan (in month)
		4. Calculates valuable KPIs:
		        - recency (month since last sale)
				- average order revenue (AOR)
				- average monthly revenue*/
---------------------------------------------------------------------------------------------------------------------
CREATE VIEW PRODUCT_REPORT AS
/*Final Query: Combines all product results into one output*/
SELECT
     product_key,
	 product_name,
	 category,
	 subcategory,
	 cost,
     TOTAL_ORDER,
	 TOTAL_CUSTOMER,
	 TOTAL_SALES,
--Segments products by revenue to identify high-Performers, Mid-Range, or Low-Performers.
	 CASE
	     WHEN TOTAL_SALES > 50000 THEN 'High-Performer'
		 WHEN TOTAL_SALES >= 10000 THEN 'Mid-Range'
		 ELSE 'Low-Performers'
	 END AS PRODUCT_SEG,
	 TOTAL_QUANTI,
	 LAST_SALE_DDATE,
-- recency (month since last sale)
	 DATEDIFF(MONTH, LAST_SALE_DDATE, GETDATE()) AS RECENCY_IN_MONTHS,
	 LIFESPAN,
	 AVG_SELL_PRICE,
--average order revenue (AOR)
     CASE
	    WHEN TOTAL_ORDER = 0 THEN 0
		ELSE TOTAL_SALES / TOTAL_ORDER
	 END AS AVG_ORDER_REVENUE,
--average monthly revenue
     CASE
	    WHEN LIFESPAN = 0 THEN 0
		ELSE TOTAL_SALES / LIFESPAN
	 END AS AVG_MONTHLY_REVENUE
FROM(

/*Product Aggrations: Summarizes key metrics at the product level*/
SELECT 
     product_key,
	 product_name,
	 category,
	 subcategory,
	 cost,
	 COUNT(DISTINCT order_number) AS TOTAL_ORDER,
	 COUNT(DISTINCT customer_key) AS TOTAL_CUSTOMER,
	 SUM(sales_amount) AS TOTAL_SALES,
	 SUM(quantity) AS TOTAL_QUANTI,
	 MAX(order_date) AS LAST_SALE_DDATE,
	 DATEDIFF(MONTH,MIN(order_date),MAX(order_date)) AS LIFESPAN,
	 ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF (quantity,0)),1) AS AVG_SELL_PRICE
FROM(
/* Base Query: Retrive core columns from fact_sales and dim_product*/
SELECT
    F.[order_number],
	F.[order_date],
	F.[customer_key],
	F.[sales_amount],
	F.[quantity],
	P.[product_key],
    P.[product_name],
    P.[category],
    P.[subcategory],
	P.[cost]
FROM [gold].[dim_products] P
LEFT JOIN [gold].[fact_sales] F
ON
  P.product_key = F.product_key
WHERE [order_date] IS NOT NULL
) AS BASED_QUERY
GROUP BY
         product_key,
	 product_name,
	 category,
	 subcategory,
	 cost
) AS PRODUCT_AGGREGATIONS



